<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><script type="text/javascript" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: "ca-pub-1919957041991194",
  enable_page_level_ads: true
});</script><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta content="author" name="ChanghuiN"><meta name="keywords" content="代码星冰乐,码小猪,I-team,聊聊 JDK 阻塞队列源码（ReentrantLock实现）,Java,ArrayBlockingQueue,LinkedBlockingQueue,源码"><meta name="description" content="&lt;p&gt;项目中用到了一个叫做 Disruptor 的队列，今天楼主并不是要介绍 Disruptor 而是想巩固一下基础扒一下 JDK 中的阻塞队列，听到队列相信大家对其并不陌生，在我们现实生活中队列随处可见，最经典的就是去银行办理业务等。&lt;br&gt;"><title>聊聊 JDK 阻塞队列源码（ReentrantLock实现） - 代码星冰乐</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script type="text/javascript" src="https://dup.baidustatic.com/js/ds.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-125332711-1" async></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-125332711-1');</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">聊聊 JDK 阻塞队列源码（ReentrantLock实现）</h1><a id="logo" href="/.">代码星冰乐<img src="/favicon.ico" alt style="width: 34px; margin-left: 5px; vertical-align: bottom;"></a><p class="description">专注成就未来</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">聊聊 JDK 阻塞队列源码（ReentrantLock实现）</h1><div class="post-meta">Jul 31, 2018<span> | </span><span class="author">haifeiWu</span><span> | </span><span class="category"><a href="/categories/Java/">Java</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="blog_value_page_pv"></span><span> 阅读</span></span><script type="text/javascript">$(function() {
  var blog_url = window.location.href.split("?")[0];
  var fet_url = "/base-service/blog_read_count_incr?blogId=" + blog_url;
  fetch(fet_url).then(function(response){
    return response.json();
  }).then(function(data) {
    $("#blog_value_page_pv").text(data.data)
  }).catch(function (e) {
    console.log(e);
  })
});</script></div><div class="clear" style="margin-top: 12em;"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-中的队列"><span class="toc-number">1.</span> <span class="toc-text">JDK 中的队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBlockingQueue-源码分析"><span class="toc-number">2.</span> <span class="toc-text">ArrayBlockingQueue 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量属性"><span class="toc-number">2.1.</span> <span class="toc-text">成员变量属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要方法源码实现"><span class="toc-number">2.2.</span> <span class="toc-text">主要方法源码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue-源码分析"><span class="toc-number">3.</span> <span class="toc-text">LinkedBlockingQueue  源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量属性-1"><span class="toc-number">3.1.</span> <span class="toc-text">成员变量属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#主要方法源码实现-1"><span class="toc-number">3.2.</span> <span class="toc-text">主要方法源码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考链接"><span class="toc-number">5.</span> <span class="toc-text">参考链接</span></a></li></ol></div></div><div class="post-content" style="margin-top: -12em; display: none;"><blockquote style="margin: 10px 0;"><p style="margin: 1em 0"><span>作 者：</span><span class="author">haifeiWu</span><br><span>原文链接：</span><a href="https://www.hchstudio.cn/article/2018/22ff/">https://www.hchstudio.cn/article/2018/22ff/</a><br><span>版权声明：非特殊声明均为本站原创作品，转载时请注明作者和原文链接。</span></p></blockquote><br><p><span> 由于版权原因，请阅读原文 --&gt; </span><a href="https://www.hchstudio.cn/article/2018/22ff/">聊聊 JDK 阻塞队列源码（ReentrantLock实现）</a></p><p> <img alt="关注我们" style="width: 66%" src="https://img.hchstudio.cn/dmxbl.jpg"></p><p style="margin-top: 40px; margin-bottom: 40px;"><span style="color: red;">作 者：</span><span class="author">haifeiWu</span><br><span style="color: red;">原文链接：</span><a href="https://www.hchstudio.cn/article/2018/22ff/">https://www.hchstudio.cn/article/2018/22ff/</a><br><span style="color: red;">版权声明：非特殊声明均为本站原创作品，转载时请注明作者和原文链接。</span></p></div><div class="post-content_private" style="margin-top: -12em;"><blockquote style="margin: 10px 0;"><p style="margin: 1em 0"><span>作 者：</span><span class="author">haifeiWu</span><br><span>原文链接：</span><a href="https://www.hchstudio.cn/article/2018/22ff/">https://www.hchstudio.cn/article/2018/22ff/</a><br><span>版权声明：非特殊声明均为本站原创作品，转载时请注明作者和原文链接。</span></p></blockquote><p>项目中用到了一个叫做 Disruptor 的队列，今天楼主并不是要介绍 Disruptor 而是想巩固一下基础扒一下 JDK 中的阻塞队列，听到队列相信大家对其并不陌生，在我们现实生活中队列随处可见，最经典的就是去银行办理业务等。<br><a id="more"></a><br>当然在计算机世界中，队列是属于一种数据结构，队列采用的FIFO(first in firstout)，新元素（等待进入队列的元素）总是被插入到尾部，而读取的时候总是从头部开始读取。在计算中队列一般用来做排队(如线程池的等待排队，锁的等待排队)，用来做解耦（生产者消费者模式），异步等等。</p>
<h2 id="JDK-中的队列"><a href="#JDK-中的队列" class="headerlink" title="JDK 中的队列"></a>JDK 中的队列</h2><p>在<strong>JDK</strong>中的队列都实现了 <strong>java.util.Queue</strong> 接口，在队列中又分为两类，一类是线程不安全的，ArrayDeque，LinkedList等等，还有一类都在<strong>java.util.concurrent</strong>包下属于线程安全，而在我们真实的环境中，我们的机器都是属于多线程，当多线程对同一个队列进行操作的时，如果使用线程不安全会出现数据丢失等无法预测的事情，所以我们这个时候只能选择线程安全的队列。下面是我们今天要探讨的两个队列</p>
<table>
<thead>
<tr>
<th style="text-align:left">队列名字</th>
<th style="text-align:right">是否加锁</th>
<th style="text-align:center">数据结构</th>
<th>关键技术点</th>
<th>是否有锁</th>
<th>是否有界</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ArrayBlockingQueue</td>
<td style="text-align:right">是</td>
<td style="text-align:center">数组array</td>
<td>ReentrantLock</td>
<td>有锁</td>
<td>有界</td>
</tr>
<tr>
<td style="text-align:left">LinkedBlockingQueue</td>
<td style="text-align:right">是</td>
<td style="text-align:center">链表</td>
<td>ReentrantLock</td>
<td>有锁</td>
<td>有界</td>
</tr>
</tbody>
</table>
<h2 id="ArrayBlockingQueue-源码分析"><a href="#ArrayBlockingQueue-源码分析" class="headerlink" title="ArrayBlockingQueue 源码分析"></a>ArrayBlockingQueue 源码分析</h2><p>ArrayBlockingQueue 的原理就是使用一个可重入锁（ReentrantLock ）和这个锁生成的两个条件对象进行并发控制，ArrayBlockingQueue是一个有界的阻塞队列，初始化的时候必须要指定队列长度，且指定长度之后不允许进行修改。<br></p>
<h3 id="成员变量属性"><a href="#成员变量属性" class="headerlink" title="成员变量属性"></a>成员变量属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items item的集合 */</span></span><br><span class="line">   <span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** items index for next take, poll, peek or remove 取出数据的索引 */</span></span><br><span class="line">   <span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** items index for next put, offer, or add 添加数据的索引 */</span></span><br><span class="line">   <span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Number of elements in the queue 队列元素的个数 */</span></span><br><span class="line">   <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Main lock guarding all access 可重入的锁 */</span></span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Condition for waiting takes 队列为空条件等待对象 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Condition for waiting puts 队列满条件等待对象 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>
<h3 id="主要方法源码实现"><a href="#主要方法源码实现" class="headerlink" title="主要方法源码实现"></a>主要方法源码实现</h3><ol>
<li>add：添加元素到队列里，添加成功返回true，由于容量满了添加失败会抛出<code>IllegalStateException</code>异常；<br></li>
<li>offer：添加元素到队列里，添加成功返回true，添加失败返回false；<br></li>
<li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满；<br></li>
<li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素；<br></li>
<li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false；<br></li>
<li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除。<br></li>
</ol>
<p><code>add</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (offer(e))</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>offer</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	checkNotNull(e);</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (count == items.length)</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			insert(e);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>put</code>方法：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        xfer(e, <span class="keyword">true</span>, ASYNC, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，如果队列满了则返回false，如果没有满调用insert。整个方法是通过可重入锁来锁住的，并且最终释放。</p>
<p>接着看一下<code>insert</code>方法：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">	items[putIndex] = x; <span class="comment">// 元素添加到数组里</span></span><br><span class="line">	putIndex = inc(putIndex); <span class="comment">// 放数据索引+1，当索引满了变成0</span></span><br><span class="line">	++count; <span class="comment">// 元素个数+1</span></span><br><span class="line">	notEmpty.signal(); <span class="comment">// 使用条件对象notEmpty通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里<code>insert</code>被调用的时候就会唤醒<code>notEmpty</code>上等待的线程进行<code>take</code>操作。<br></p>
<p>再看一下<code>put</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	checkNotNull(e); <span class="comment">// 不允许元素为空</span></span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lockInterruptibly(); <span class="comment">// 加锁，保证调用put方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (count == items.length) <span class="comment">// 如果队列满了，阻塞当前线程，while用来防止假唤醒</span></span><br><span class="line">			notFull.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span></span><br><span class="line">		insert(e); <span class="comment">// 调用insert方法</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock(); <span class="comment">// 释放锁，让其他线程可以调用put方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面代码我们可以知道，<code>add</code>方法和<code>offer</code>方法不会阻塞线程，<code>put</code>方法如果队列满了会阻塞线程，直到有线程消费了队列里的数据才有可能被唤醒。<br></p>
<p>紧接着我们看一下<code>poll</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lock(); <span class="comment">// 加锁，保证调用poll方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : extract(); <span class="comment">// 如果队列里没元素了，返回null，否则调用extract方法</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock(); <span class="comment">// 释放锁，让其他线程可以调用poll方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看看这个<code>extract</code>方法，extract的翻译过来就是提取的意思：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">	E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]); <span class="comment">// 得到取索引位置上的元素</span></span><br><span class="line">	items[takeIndex] = <span class="keyword">null</span>; <span class="comment">// 对应取索引上的数据清空</span></span><br><span class="line">	takeIndex = inc(takeIndex); <span class="comment">// 取数据索引+1，当索引满了变成0</span></span><br><span class="line">	--count; <span class="comment">// 元素个数-1</span></span><br><span class="line">	notFull.signal(); <span class="comment">// 使用条件对象notFull通知，原理同上面的insert中</span></span><br><span class="line">	<span class="keyword">return</span> x; <span class="comment">// 返回元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看一下<code>take</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lockInterruptibly(); <span class="comment">// 加锁，保证调用take方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// 如果队列空，阻塞当前线程，并加入到条件对象notEmpty的等待队列里</span></span><br><span class="line">			notEmpty.await(); <span class="comment">// 线程阻塞并被挂起，同时释放锁</span></span><br><span class="line">		<span class="keyword">return</span> extract(); <span class="comment">// 调用extract方法</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock(); <span class="comment">// 释放锁，让其他线程可以调用take方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">	lock.lock(); <span class="comment">// 加锁，保证调用remove方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = takeIndex, k = count; k &gt; <span class="number">0</span>; i = inc(i), k--) &#123; <span class="comment">// 遍历元素</span></span><br><span class="line">			<span class="keyword">if</span> (o.equals(items[i])) &#123; <span class="comment">// 两个对象相等的话</span></span><br><span class="line">				removeAt(i); <span class="comment">// 调用removeAt方法</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 删除成功，返回true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 删除成功，返回false</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock(); <span class="comment">// 释放锁，让其他线程可以调用remove方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看一下<code>removeAt</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">	<span class="keyword">if</span> (i == takeIndex) &#123; </span><br><span class="line">		<span class="comment">// 如果要删除数据的索引是取索引位置，直接删除取索引位置上的数据，然后取索引+1即可</span></span><br><span class="line">		items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">		takeIndex = inc(takeIndex);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="comment">// 如果要删除数据的索引不是取索引位置，移动元素元素，更新取索引和放索引的值</span></span><br><span class="line">		<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">			<span class="keyword">int</span> nexti = inc(i);</span><br><span class="line">			<span class="keyword">if</span> (nexti != putIndex) &#123;</span><br><span class="line">				items[i] = items[nexti];</span><br><span class="line">				i = nexti;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				items[i] = <span class="keyword">null</span>;</span><br><span class="line">				putIndex = i;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	--count; <span class="comment">// 元素个数-1</span></span><br><span class="line">	notFull.signal(); <span class="comment">// 使用条件对象notFull通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LinkedBlockingQueue-源码分析"><a href="#LinkedBlockingQueue-源码分析" class="headerlink" title="LinkedBlockingQueue  源码分析"></a>LinkedBlockingQueue  源码分析<br></h2><p><code>LinkedBlockingQueue</code>是一个使用链表完成队列操作的阻塞队列。<strong>链表是单向链表，而不是双向链表</strong>。</p>
<h3 id="成员变量属性-1"><a href="#成员变量属性-1" class="headerlink" title="成员变量属性"></a>成员变量属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The capacity bound, or Integer.MAX_VALUE if none 容量大小 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Current number of elements 元素个数，因为有2个锁，存在竞态条件，使用AtomicInteger */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Head of linked list.</span></span><br><span class="line"><span class="comment">    * Invariant: head.item == null</span></span><br><span class="line"><span class="comment">    * 头结点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tail of linked list.</span></span><br><span class="line"><span class="comment">    * Invariant: last.next == null</span></span><br><span class="line"><span class="comment">    * 尾节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock held by take, poll, etc 获取元素的锁 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting takes 取元素的条件对象 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Lock held by put, offer, etc 放元素的锁 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/** Wait queue for waiting puts 添加元素的条件对象 */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<h3 id="主要方法源码实现-1"><a href="#主要方法源码实现-1" class="headerlink" title="主要方法源码实现"></a>主要方法源码实现</h3><p>由于文章篇幅问题对于<code>LinkedBlockingQueue</code>我们主要分析以下几个方法：</p>
<ol>
<li>offer：添加元素到队列里，添加成功返回true，添加失败返回false；<br></li>
<li>put：添加元素到队列里，如果容量满了会阻塞直到容量不满；<br></li>
<li>poll：删除队列头部元素，如果队列为空，返回null。否则返回元素；<br></li>
<li>remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false；<br></li>
<li>take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除。<br></li>
</ol>
<p><code>offer</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 不允许空元素</span></span><br><span class="line">	<span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">	<span class="keyword">if</span> (count.get() == capacity) <span class="comment">// 如果容量满了，返回false</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">	Node&lt;E&gt; node = <span class="keyword">new</span> Node(e); <span class="comment">// 容量没满，以新元素构造节点</span></span><br><span class="line">	<span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">	putLock.lock(); <span class="comment">// 放锁加锁，保证调用offer方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 再次判断容量是否已满，因为可能取元素锁在进行消费数据，没满的话继续执行</span></span><br><span class="line">		<span class="keyword">if</span> (count.get() &lt; capacity) &#123; </span><br><span class="line">			enqueue(node); <span class="comment">// 节点添加到链表尾部</span></span><br><span class="line">			c = count.getAndIncrement(); <span class="comment">// 元素个数+1</span></span><br><span class="line">			<span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 如果容量还没满</span></span><br><span class="line">				notFull.signal(); <span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		putLock.unlock(); <span class="comment">// 释放放锁，让其他线程可以调用offer方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 由于存在放元素锁和取元素锁，这里可能取元素锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>) </span><br><span class="line">		<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span></span><br><span class="line">        signalNotEmpty(); </span><br><span class="line">	<span class="keyword">return</span> c &gt;= <span class="number">0</span>; <span class="comment">// 添加成功返回true，否则返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>put</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(); <span class="comment">// 不允许空元素</span></span><br><span class="line">	<span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">	Node&lt;E&gt; node = <span class="keyword">new</span> Node(e); <span class="comment">// 以新元素构造节点</span></span><br><span class="line">	<span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">	<span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">	putLock.lockInterruptibly(); <span class="comment">// 放锁加锁，保证调用put方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (count.get() == capacity) &#123; <span class="comment">// 如果容量满了</span></span><br><span class="line">			notFull.await(); <span class="comment">// 阻塞并挂起当前线程</span></span><br><span class="line">		&#125;</span><br><span class="line">		enqueue(node); <span class="comment">// 节点添加到链表尾部</span></span><br><span class="line">		c = count.getAndIncrement(); <span class="comment">// 元素个数+1</span></span><br><span class="line">		<span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity) <span class="comment">// 如果容量还没满</span></span><br><span class="line">			<span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的线程，表示可以再次往队列里面加数据了，队列还没满</span></span><br><span class="line">			notFull.signal();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		putLock.unlock(); <span class="comment">// 释放放锁，让其他线程可以调用put方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 由于存在放锁和拿锁，这里可能拿锁一直在消费数据，count会变化。这里的if条件表示如果队列中还有1条数据</span></span><br><span class="line">	<span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的1个线程，表示队列里还有1条数据，可以进行消费</span></span><br><span class="line">		signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>poll</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">	<span class="keyword">if</span> (count.get() == <span class="number">0</span>) <span class="comment">// 如果元素个数为0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回null</span></span><br><span class="line">	E x = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">	takeLock.lock(); <span class="comment">// 拿锁加锁，保证调用poll方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123; <span class="comment">// 判断队列里是否还有数据</span></span><br><span class="line">			x = dequeue(); <span class="comment">// 删除头结点</span></span><br><span class="line">			c = count.getAndDecrement(); <span class="comment">// 元素个数-1</span></span><br><span class="line">			<span class="keyword">if</span> (c &gt; <span class="number">1</span>) <span class="comment">// 如果队列里还有元素</span></span><br><span class="line">				<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span></span><br><span class="line">				notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock(); <span class="comment">// 释放拿锁，让其他线程可以调用poll方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">		<span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据</span></span><br><span class="line">		signalNotFull(); </span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>take</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	E x;</span><br><span class="line">	<span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">	<span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">	takeLock.lockInterruptibly(); <span class="comment">// 拿锁加锁，保证调用take方法的时候只有1个线程</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123; <span class="comment">// 如果队列里已经没有元素了</span></span><br><span class="line">			notEmpty.await(); <span class="comment">// 阻塞并挂起当前线程</span></span><br><span class="line">		&#125;</span><br><span class="line">		x = dequeue(); <span class="comment">// 删除头结点</span></span><br><span class="line">		c = count.getAndDecrement(); <span class="comment">// 元素个数-1</span></span><br><span class="line">		<span class="keyword">if</span> (c &gt; <span class="number">1</span>) <span class="comment">// 如果队列里还有元素</span></span><br><span class="line">			<span class="comment">// 在拿锁的条件对象notEmpty上唤醒正在等待的线程，表示队列里还有数据，可以再次消费</span></span><br><span class="line">			notEmpty.signal(); </span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		takeLock.unlock(); <span class="comment">// 释放拿锁，让其他线程可以调用take方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 由于存在放锁和拿锁，这里可能放锁一直在添加数据，count会变化。这里的if条件表示如果队列中还可以再插入数据</span></span><br><span class="line">	<span class="keyword">if</span> (c == capacity) </span><br><span class="line">		<span class="comment">// 在放锁的条件对象notFull上唤醒正在等待的1个线程，表示队列里还能再次添加数据</span></span><br><span class="line">		signalNotFull(); </span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove</code>方法：<br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	fullyLock(); <span class="comment">// remove操作要移动的位置不固定，对读锁写锁都进行加锁</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next; <span class="comment">// 从链表头结点开始遍历</span></span><br><span class="line">			p != <span class="keyword">null</span>;</span><br><span class="line">			trail = p, p = p.next) &#123;</span><br><span class="line">			<span class="keyword">if</span> (o.equals(p.item)) &#123; <span class="comment">// 判断是否找到对象</span></span><br><span class="line">				unlink(p, trail); <span class="comment">// 修改节点的链接信息，同时调用notFull的signal方法</span></span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		fullyUnlock(); <span class="comment">// 2个锁解锁</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着来看一下 <code>fullyLock</code>与<code>fullyUnlock</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Locks to prevent both puts and takes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     putLock.lock();</span><br><span class="line">     takeLock.lock();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Unlocks to allow both puts and takes.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     takeLock.unlock();</span><br><span class="line">     putLock.unlock();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LinkedBlockingQueue</code>的take方法对于没数据的情况下会阻塞，<code>poll</code>方法删除链表头结点，remove方法删除指定的对象。<br></p>
<p><strong>需要注意的是<code>remove</code>方法由于要删除的数据的位置不确定，需要2个锁同时加锁。</strong><br></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文章有点长，JDK中的阻塞队列线程安全的主要有<code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>，<code>LinkedTransferQueue</code>，<code>DelayQueue</code>四种，今天楼主把<code>ArrayBlockingQueue</code>，<code>LinkedBlockingQueue</code>放在一起介绍主要原因是这两者都是使用可重入锁 <code>ReentrantLock</code>实现的线程安全。<br>当然二者也有很大的不同，主要是：</p>
<p>1，<code>ArrayBlockingQueue</code>只有1个锁，添加数据和删除数据的时候只能有1个被执行，不允许并行执行。<br>而<code>LinkedBlockingQueue</code>有2个锁，放元素锁和取元素锁，添加数据和删除数据是可以并行进行的，当然添加数据和删除数据的时候只能有1个线程各自执行。<br></p>
<p>2，<code>ArrayBlockingQueue</code>中放入数据阻塞的时候，需要消费数据才能唤醒。<br>而<code>LinkedBlockingQueue</code>中放入数据阻塞的时候，因为它内部有2个锁，可以并行执行放入数据和消费数据，不仅在消费数据的时候进行唤醒插入阻塞的线程，同时在插入的时候如果容量还没满，也会唤醒插入阻塞的线程。<br></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://juejin.im/post/5b5f10d65188251ad06b78e3" target="_blank" rel="noopener">还在用阻塞队列？Disruptor了解一下？</a></li>
</ul>
<p> <img alt="关注我们" style="width: 66%" src="https://img.hchstudio.cn/dmxbl.jpg"></p><p style="margin-top: 40px; margin-bottom: 40px;"><span style="color: red;">作 者：</span><span class="author">haifeiWu</span><br><span style="color: red;">原文链接：</span><a href="https://www.hchstudio.cn/article/2018/22ff/">https://www.hchstudio.cn/article/2018/22ff/</a><br><span style="color: red;">版权声明：非特殊声明均为本站原创作品，转载时请注明作者和原文链接。</span></p></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="https://www.hchstudio.cn/article/2018/22ff/" data-id="ckrdhz6hl00d1smpvdmz7mnse" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACHUlEQVR42u3aS46DMBAFwNz/0sx2pCjkdTdEwi6vogxgKgtP/16veB1v6//3+TWf7np/wuuOhYGB8VjGcbo+bZDcdf7S50+u7oKBgbED49MJ1vt8fgT39vryzhgYGBjBMXrtEYyBgYFxHyPJMXtJMgYGBkaSxJ4/el6Y+1EujoGB8UBGXnX//edb+hsYGBiPYhzFldw7ea2jtTAwMNZm5NvkwVy1MRklqElKjIGBsQ2jt31vtCsZ6Sgc2RgYGBsw5q3H+Q/UK9hhYGCszZiMlubfVFPfcgKMgYGxGSMprlW3rDYdqwkzBgbGDoxeiX9CrQ5PfLkGAwNjaUZelL+qrJ+0QntpMAYGxm6Ma0cuJmMZvSYoBgbGPoz8IE6CvF442AwTMTAwlmMc41VNd6vrgqIbBgbGYxnJC1UDwfsKcF+GLTAwMJZmTNqZ1WuubQBgYGDswMibAdVjtHfg9loUGBgYOzDyFuNVw169lLWQGGNgYCzHKLQG49dKinGTMYsv/zcwMDAWZeQDW9UDsZmUFv+KgYGxDyNPHSdbliPW3rAFBgbGEozeUEXy6r1kNT/oMTAw9mHkKy/f99La5OfI98LAwFiPMRlOnWxcTZ5HASIGBsYSjGqoVx08zZPkZkkOAwMDoxjSzVsI5SQWAwMD44bxi2oKfUtoiIGB8ShGksT2xjJ6T84HyzAwMHZgjFLHuG3Qawz0glQMDIyFGH9Z2eTzHefgLwAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/Java/" target="_blank">Java</a><a href="/tags/源码解析/" target="_blank">源码解析</a></div><div class="post-nav"><a class="pre" href="/article/2018/efed/">聊聊 JDK 非阻塞队列源码（CAS实现）</a><a class="next" href="/article/2018/b903/">JDK 定时任务 Timer 与 ScheduledExecutorService 排坑记录</a></div><div id="gitalk-container"></div><link rel="stylesheet" type="text/css" href="/css/gitalk.css"><script type="text/javascript" src="/js/gitalk.min.js"></script><script>var gitalk = new Gitalk({
  clientID: '66106b18af72ad1fe98a',
  clientSecret: '5602bdf32cf5f90c31001be000afd88a48d6f563',
  repo: 'ChanghuiN.github.io',
  owner: 'ChanghuiN',
  admin: ['ChanghuiN'],
  id: location.pathname.split('/').slice(-2,-1)[0],
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script><script>var cpro_id = "u3438285";</script><script src="https://cpro.baidustatic.com/cpro/ui/cm.js"></script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget" style="margin-bottom: 20px"><img style="width: 100%" src="https://img.hchstudio.cn/qrcode_for_gh_e1d420c73d96_430.jpg"><sapn style="display: block; text-align: center">微信关注我们</sapn></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">59</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kafka-Java/">Kafka,Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MapReduce/">MapReduce</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Raft/">Raft</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Redis/">Redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ThreadPoolExecutor/">ThreadPoolExecutor</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/旅游日记/">旅游日记</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/ChanghuiN/" style="font-size: 15px;">ChanghuiN</a> <a href="/tags/haifeiWu/" style="font-size: 15px;">haifeiWu</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/Kotlin/" style="font-size: 15px;">Kotlin</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/源码解析/" style="font-size: 15px;">源码解析</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/Kafka/" style="font-size: 15px;">Kafka</a> <a href="/tags/配置中心/" style="font-size: 15px;">配置中心</a> <a href="/tags/总结/" style="font-size: 15px;">总结</a> <a href="/tags/性能优化/" style="font-size: 15px;">性能优化</a> <a href="/tags/旅游日记/" style="font-size: 15px;">旅游日记</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/问题排查/" style="font-size: 15px;">问题排查</a> <a href="/tags/译文/" style="font-size: 15px;">译文</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/Spring-Boot/" style="font-size: 15px;">Spring Boot</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/学习笔记/" style="font-size: 15px;">学习笔记</a> <a href="/tags/WebFlux/" style="font-size: 15px;">WebFlux</a> <a href="/tags/性能测试/" style="font-size: 15px;">性能测试</a> <a href="/tags/go/" style="font-size: 15px;">go</a> <a href="/tags/散列表/" style="font-size: 15px;">散列表</a> <a href="/tags/源码/" style="font-size: 15px;">源码</a> <a href="/tags/netty/" style="font-size: 15px;">netty</a> <a href="/tags/Raft/" style="font-size: 15px;">Raft</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/article/2021/7cba/">Kafka的日志复制机制</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2021/8e2f/">从20到21</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/e8fc/">go 并发编程</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/ce5a/">【译】了解Linux CPU负载-您何时应该担心？</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/4d59/">Zookeeper 与分布式锁</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/7bc5/">基于Redis的分布式锁到底安全吗？</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/62e/">【译】Raft 学生指南</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/c5a/">ThreadPoolExecutor 的简单梳理</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/1ed5/">MapReduce 的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/article/2020/4a72/">使用 Map 实现策略模式</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 福利专区</i></div><ul></ul><a href="https://cloud.tencent.com/redirect.php?redirect=1009&amp;cps_key=c809e5f9177c6354f546e3e79ffba96f&amp;from=console" title="免费SSL证书" target="_blank">免费SSL证书</a><ul></ul><a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=mqspr2q3" title="阿里云红包" target="_blank">阿里云红包</a><ul></ul><a href="https://cloud.tencent.com/redirect.php?redirect=1025&amp;cps_key=c809e5f9177c6354f546e3e79ffba96f&amp;from=console" title="腾讯云专属福利" target="_blank">腾讯云专属福利</a></div><div class="widget"><div class="widget-title"><script>var cpro_id = "u3438277";</script><script src="//cpro.baidustatic.com/cpro/ui/c.js"></script><script>var cpro_id = "u3438277";</script><script src="//cpro.baidustatic.com/cpro/ui/c.js"></script><script>var cpro_id = "u3438277";</script><script src="//cpro.baidustatic.com/cpro/ui/c.js"></script></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">代码星冰乐.</a> Powered by<a rel="nofollow" target="_blank" style="font-weight: bold" href="https://www.hchstudio.cn"> ChanghuiN.</a> 版权所有 晋ICP备15001365号<br><span>特别感谢：</span><a rel="nofollow" target="_blank" style="font-weight: bold" href="https://cloud.tencent.com/redirect.php?redirect=1005&amp;cps_key=c809e5f9177c6354f546e3e79ffba96f&amp;from=console."> 云服务器服务商</a> 、<a rel="nofollow" target="_blank" style="font-weight: bold" href="https://portal.qiniu.com/signup?code=3lor2p0wm2frm."> CDN 服务商</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.3.5/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?57858db5693024385f944247dd150c32";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script>(function(){
  var bp = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https'){
  bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
} else{
  bp.src = 'https://push.zhanzhang.baidu.com/push.js';
}
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})();</script></div></body></html>